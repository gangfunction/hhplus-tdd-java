항해플러스 백엔드 5기 테스트 주도개발 프로젝트
1. 개발과정 [패키지 (테스트), (메인)]
    1. (테스트) 실패하는 컨트롤러 테스트 작성
        1. PointService가 필요한 메서드를 구현
        2. (테스트) PointService 클래스 생성
        3. (테스트) PointService 모킹
        4. when, thenReturn, verify 를 사용하여 PointService 의 메서드 호출여부를 테스트 -> 실패
        5. PointService의 메서드를 구현 (point, history, charge, use)
        6. 메소드 호출여부를 재 테스트 -> 성공
        7. MockMvc가 UserPoint를 반환하도록 수정 -> 성공
    2. (테스트) 실패하는 서비스 테스트 작성
        1. id값이 음수가 들어오면 예외를 던지는지 테스트
        2. 결과값이 없을때 0을 반환하는지 테스트
        3. charge 에 충전되고나서 정상적으로 조회되는지 테스트
        4. charge 에 2회이상 충전하고나서 정상적으로 조회되는지 테스트
        5. charge 에 Long.MAX_VALUE 보다 큰 값을 넣었을때 예외를 던지는지 테스트
        6. charge 에 음수를 입력하고 예외를 던지는지 테스트
        7. use 에 사용되고나서 정상적으로 조회되는지 테스트
        8. use 가 현재 포인트보다 큰 값을 입력했을때 예외를 던지는지 테스트
        9. use 에 음수를 입력하고 예외를 던지는지 테스트
        10. history 에 히스토리가 정상적으로 조회되는지 테스트
        11. history 에 히스토리가 없을때 빈 리스트를 반환하는지 테스트
        12. history 에 충전을 하고나서 히스토리가 조회되는지 테스트
        13. history 에 사용을 하고나서 히스토리가 조회되는지 테스트
        14. history 에 충전,사용을 하고나서 히스토리가 조회되는지 테스트
    3. (테스트) 성공하는 서비스 클래스 구현 및 서비스 패키지 이동 (테스트 -> 메인)
    4. Service와 Repository 분리를 위한 작업
       1. (테스트) PointService 에서 PointRepository 를 사용하도록 수정
       2. (테스트) interface PointRepository 생성
       3. (테스트) PointRepository 에서 해야할 행위등을 정의
       4. (테스트) PointRepository 에서 해야할 행위를 구현 구현체, RepositoryImpl 생성
       5. 서비스 테스트 재실행 -> 성공
       6. PointRepository, PointRepositoryImpl을 패키지 이동 (테스트 -> 메인)

2. 개선과정
   1. 컨트롤러 테스트의 목적은 api 스펙준수에 맞추어야한다면 가능하면 결합도가 낮은상태에서 시행해야하지않을까?
      1. 입력값에 대한 검증을 위해 @ParameterizedTest 와 @MethodSource 를 사용해 임의의 long 값을 입력
      2. 하지만 long 타입이 강제해주기때문에, long 값이내의 테스트는 무의미 해보인다...?
   2. 동시성에 대한 고려가 필요하다면 어떻게 해야할까?
      1. 동시성으로 이슈가 되는 상태들에 대해서 조사해보자.
         1. 레이스컨디션 : 두개 이상의 스레드가 동시에 같은 데이터를 변경할때 예상되는 결과값이 나오지않는 문제
         2. 데드락 : 두개 이상의 스레드가 서로의 락을 기다리는 상황
         3. 로스트 업데이트 : 두개 이상의 스레드가 동시에 같은 데이터를 변경할때 업데이트값이 조회되지않는 문제
         4. 논 리피터블 리드 : 같은 쿼리를 반복할때 업데이트 쿼리로 인하여 결과가 달라지는 문제
         5. 팬텀 읽기 : 같은 쿼리를 반복했으나 예상되지않은 값을 읽어오는 문제
      2. 마찬가지로 이에 대해서 테스트를 작성해보고 실행해보자.
         1. executeService 를 사용하여 동시성 테스트를 진행 -> 실패 : 종료조건이 설정이 안되어있습니다.
         2. countDownLatch 를 사용하여 동시성 테스트를 진행 -> 성공 : 문제상황이 정확하게 구현이되었습니다.
      3. 주요 문제가 되는 동시성의 이슈가 발생하는 부분은 어디일까? -> 포인트 충전, 포인트 사용
      4. 포인트 충전과 포인트 사용에서 동시성이 발생하는 이유는 무엇일까?
         1. 포인트 충전과 사용 요청이 순서가 보장되지 않고, 값이 업데이트 되는 부분도 원자성을 보장하지 못했습니다.
         2. 그럴때는 대기열을 받아서 처리를 해보면 되지않을까?
         3. BlockingQueue vs ConcurrentLinkedQueue
            1. BlockingQueue : put, take 메서드를 사용하여 블로킹을 걸어서 대기열을 처리
            2. ConcurrentLinkedQueue : offer, poll 메서드를 사용하여 블로킹을 걸지않고 대기열을 처리
         4. 실시간성을 보장하기위해서는 ConcurrentLinkedQueue 라고 판단했고 객체에 타임스탬프를 추가하고 이를 사용하여 구현했습니다.
         5. 테스트를 통해 동시성 이슈가 해결되었는지 확인해보자.
            1. executeService 를 사용하여 동시성 테스트를 진행 -> 값이 제대로 업데이트가 되지 않는 문제 발생
            2. AtomicLong 을 사용하여 들어오는 값마다 비교연산을 수행하고 업데이트되는 값마다 update연산을 수행함으로 추가적인 포인트 조회가 발생하지 않았습니다.
            3. 다시 테스트를 진행해보자. -> 성공
      5. 테스트가 성공했으니 큐의 로직과 서비스의 로직을 연결시켜보자.
      6. 연결후 동시성 테스트를 진행해보자 -> 성공
      7. 동시성 테스트가 성공했으니 다시 서비스 테스트가 성공하는지 확인해보자 -> 실패
   3. 동시성을 개선했는데 왜 서비스 테스트가 실패했을까?
      1. 조회는 큐가 작업하는것을 기다리지 않고 바로 반영하기때문에 조회가 실패했습니다.
      2. 조회가 큐가 작업하는것을 기다리려면 어떻게해야할까?
         1. CompletableFuture 를 사용하여 조회를 큐가 작업하는것을 기다리도록 수정
         2. 테스트를 다시 진행해보자 -> 성공

3. 마무리
   1. 현재 상태에서의 문제점
      1. 발제에 맞춰서 DTO를 생성해야했지만, DTO를 생성하지않고 파라미터를 받아서 처리했습니다.
      2. 응답객체를 반환할때 있어서 UserPoint 객체를 반환했지만, UserPoint 객체에는 Http 상태가 담기지 않았습니다.
         1. ResponseEntity 를 사용하여 Http 상태를 담아서 반환하도록 수정
         2. 에러의 경우에는 기존 컨트롤러어드바이스를 활용하여 예외처리를 하도록 수정