## 항해플러스 백엔드 5기 테스트 주도개발 프로젝트

### 1. 개발과정

#### 1.1 패키지 (테스트), (메인)

##### 1.1.1 (테스트) 실패하는 컨트롤러 테스트 작성
1. `PointService`가 필요한 메서드를 구현
2. (테스트) `PointService` 클래스 생성
3. (테스트) `PointService` 모킹
4. `when`, `thenReturn`, `verify`를 사용하여 `PointService`의 메서드 호출 여부를 테스트 -> 실패
5. `PointService`의 메서드를 구현 (point, history, charge, use)
6. 메소드 호출 여부를 재 테스트 -> 성공
7. `MockMvc`가 `UserPoint`를 반환하도록 수정 -> 성공

##### 1.1.2 (테스트) 실패하는 서비스 테스트 작성
1. `id` 값이 음수가 들어오면 예외를 던지는지 테스트
2. 결과값이 없을 때 0을 반환하는지 테스트
3. `charge`에 충전되고 나서 정상적으로 조회되는지 테스트
4. `charge`에 2회 이상 충전하고 나서 정상적으로 조회되는지 테스트
5. `charge`에 `Long.MAX_VALUE`보다 큰 값을 넣었을 때 예외를 던지는지 테스트
6. `charge`에 음수를 입력하고 예외를 던지는지 테스트
7. `use`에 사용되고 나서 정상적으로 조회되는지 테스트
8. `use`가 현재 포인트보다 큰 값을 입력했을 때 예외를 던지는지 테스트
9. `use`에 음수를 입력하고 예외를 던지는지 테스트
10. `history`에 히스토리가 정상적으로 조회되는지 테스트
11. `history`에 히스토리가 없을 때 빈 리스트를 반환하는지 테스트
12. `history`에 충전을 하고 나서 히스토리가 조회되는지 테스트
13. `history`에 사용을 하고 나서 히스토리가 조회되는지 테스트
14. `history`에 충전, 사용을 하고 나서 히스토리가 조회되는지 테스트

##### 1.1.3 (테스트) 성공하는 서비스 클래스 구현 및 서비스 패키지 이동 (테스트 -> 메인)

##### 1.1.4 Service와 Repository 분리를 위한 작업
1. (테스트) `PointService`에서 `PointRepository`를 사용하도록 수정
2. (테스트) `interface PointRepository` 생성
3. (테스트) `PointRepository`에서 해야 할 행위 등을 정의
4. (테스트) `PointRepository`에서 해야 할 행위를 구현, 구현체 `RepositoryImpl` 생성
5. 서비스 테스트 재실행 -> 성공
6. `PointRepository`, `PointRepositoryImpl`을 패키지 이동 (테스트 -> 메인)

### 2. 개선과정

#### 2.1 컨트롤러 테스트의 목적은 API 스펙 준수에 맞추어야 한다면 가능하면 결합도가 낮은 상태에서 시행해야 하지 않을까?
1. 입력값에 대한 검증을 위해 `@ParameterizedTest`와 `@MethodSource`를 사용해 임의의 `long` 값을 입력
2. 하지만 `long` 타입이 강제해주기 때문에, `long` 값 이내의 테스트는 무의미해 보인다...?

#### 2.2 동시성에 대한 고려가 필요하다면 어떻게 해야 할까?
1. 동시성으로 이슈가 되는 상태들에 대해서 조사해보자.
    1. 레이스컨디션: 두 개 이상의 스레드가 동시에 같은 데이터를 변경할 때 예상되는 결과값이 나오지 않는 문제
    2. 데드락: 두 개 이상의 스레드가 서로의 락을 기다리는 상황
    3. 로스트 업데이트: 두 개 이상의 스레드가 동시에 같은 데이터를 변경할 때 업데이트값이 조회되지 않는 문제
    4. 논 리피터블 리드: 같은 쿼리를 반복할 때 업데이트 쿼리로 인하여 결과가 달라지는 문제
    5. 팬텀 읽기: 같은 쿼리를 반복했으나 예상되지 않은 값을 읽어오는 문제
2. 마찬가지로 이에 대해서 테스트를 작성해보고 실행해보자.
    1. `executeService`를 사용하여 동시성 테스트를 진행 -> 실패: 종료 조건이 설정이 안 되어 있습니다.
    2. `countDownLatch`를 사용하여 동시성 테스트를 진행 -> 성공: 문제 상황이 정확하게 구현되었습니다.
3. 주요 문제가 되는 동시성의 이슈가 발생하는 부분은 어디일까? -> 포인트 충전, 포인트 사용
4. 포인트 충전과 포인트 사용에서 동시성이 발생하는 이유는 무엇일까?
    1. 포인트 충전과 사용 요청이 순서가 보장되지 않고, 값이 업데이트되는 부분도 원자성을 보장하지 못했습니다.
    2. 그럴 때는 대기열을 받아서 처리를 해보면 되지 않을까?
    3. `BlockingQueue` vs `ConcurrentLinkedQueue`
        1. `BlockingQueue`: `put`, `take` 메서드를 사용하여 블로킹을 걸어서 대기열을 처리
        2. `ConcurrentLinkedQueue`: `offer`, `poll` 메서드를 사용하여 블로킹을 걸지 않고 대기열을 처리
    4. 실시간성을 보장하기 위해서는 `ConcurrentLinkedQueue`라고 판단했고 객체에 타임스탬프를 추가하고 이를 사용하여 구현했습니다.
    5. 테스트를 통해 동시성 이슈가 해결되었는지 확인해보자.
        1. `executeService`를 사용하여 동시성 테스트를 진행 -> 값이 제대로 업데이트가 되지 않는 문제 발생
        2. `AtomicLong`을 사용하여 들어오는 값마다 비교 연산을 수행하고 업데이트되는 값마다 `update` 연산을 수행함으로 추가적인 포인트 조회가 발생하지 않았습니다.
        3. 다시 테스트를 진행해보자. -> 성공
5. 테스트가 성공했으니 큐의 로직과 서비스의 로직을 연결시켜보자.
6. 연결 후 동시성 테스트를 진행해보자 -> 성공
7. 동시성 테스트가 성공했으니 다시 서비스 테스트가 성공하는지 확인해보자 -> 실패

#### 2.3 동시성을 개선했는데 왜 서비스 테스트가 실패했을까?
1. 조회는 큐가 작업하는 것을 기다리지 않고 바로 반영하기 때문에 조회가 실패했습니다.
2. 조회가 큐가 작업하는 것을 기다리려면 어떻게 해야 할까?
    1. `CompletableFuture`를 사용하여 조회를 큐가 작업하는 것을 기다리도록 수정
    2. 테스트를 다시 진행해보자 -> 성공

### 3. 마무리

#### 3.1 현재 상태에서의 문제점
1. 발제에 맞춰서 DTO를 생성해야 했지만, DTO를 생성하지 않고 파라미터를 받아서 처리했습니다.
2. 응답 객체를 반환할 때 있어서 `UserPoint` 객체를 반환했지만, `UserPoint` 객체에는 Http 상태가 담기지 않았습니다.
    1. `ResponseEntity`를 사용하여 Http 상태를 담아서 반환하도록 수정
    2. 에러의 경우에는 기존 컨트롤러 어드바이스를 활용하여 예외 처리를 하도록 수정

### 4. 프로젝트 리팩토링 과정

#### 리팩토링 과정

#####  1. 리팩토링 준비
1. 리팩토링에 앞서 현재 테스트가 성공하는지 확인했습니다.
2. 테스트가 성공했으니 통합 테스트에 대한 궁금증보다 실제로 동작했는지 검증을 해보고 싶었습니다. -> 실패
3. 실패했으니 테스트를 다시 진행해보자 -> 성공
4. 왜지??? 말로만 듣던 거짓양성인가?
5. 현재 queue를 작동하는 메소드는 테스트 코드상에서 수동으로 작동시켜주었지만, 실제에서는 동작하지 않는 것을 확인했습니다.

##### 2. 통합 테스트 환경 구축
1. 어디서 실패한 건지도 모르는 상태로 하나하나 뜯어가보면서 호출 순서를 뜯어봐야 하나?를 생각했을 때, 금요일까지 완성을 못할 것 같았습니다.
2. 그러면 통합 테스트 환경을 구축해 정확히 뭐가 들어가고 들어가는 것들에 대해서 제가 알고 있는 상태에서 진행을 해야겠다고 생각했습니다.
3. 통합 테스트를 구축하기 위해 @SpringBootTest와 TestRestTemplate 또는 RestTemplate를 활용하도록 시도해봤습니다.
4. 엥 안됐습니다. 정확히는 IOException 오류가 나와서 RestTemplate 종류에 PATCH가 없다고 나왔습니다.
5. 그러면 Patch를 Put으로 바꿔서 해봐야 하나? 또는 HttpClient를 의존성을 추가해야 하나 생각을 하게 되었습니다.

##### 3. 통합 테스트 진행
1. 전제조건이 기본 템플릿에서 최대한 변형하지 않고 있는 것에서 최대한 활용해야 한다는 것을 다시 명심했습니다.
2. SpringBoot 3.2에서 사용하는 Rest 통신용 클래스를 찾아봤습니다.
3. WebClient와 RestClient 두 개가 존재했습니다.
4. RestClient를 사용해서 통합 테스트를 진행해야겠다고 생각하여 RestClient를 사용하여 통합 테스트를 진행했습니다.
5. 통합 테스트를 진행하면서 충전 테스트를 구현까지는 쉬웠지만 사용 테스트에서 RestClient에서 요청이 엉켜서 제대로 조회되지 않았습니다.
6. WebClient로 바꿔야 하나? 생각이 들었을 때, WebClient는 WebFlux 의존성이 있기에, 다시 RestClient로 해결해야겠다고 생각했습니다.
7. 지금까지 썼던 기술들에 기반하여 결국 스레드에서 순서만 강제하면 되지 않을까? 싶어 ExecutorService와 CountDownLatch를 활용하여 순서를 강제했습니다.
8. 통합 테스트가 성공적으로 실패했기 때문에 이제 어디서 문제가 발생하는지 확인할 수 있게 되었습니다.

##### 4. 스케줄링 구현
1. @Scheduled 어노테이션에서 ThreadPoolTaskScheduler를 활용해서 스케줄링을 진행했습니다.
2. 설정은 빈이 시작한 시간부터 1초마다 실행되도록 설정했고, 큐 사이즈가 10이 넘을 때 같이 실행될 수 있도록 혼합적으로 구성했습니다.
3. 이에 따라 테스트들이 성공하기 시작했지만 문제는 정확하게 성능에 대해서 초당 몇 건의 처리가 가능한지 가늠이 잘 되지 않았습니다.
4. 그래서 차주 혹은 그 다음 주에 어떤 성능이 서버 구축에 주요한 팩터인지 확인하는 연습을 할 생각이 들었습니다.

##### 5. 테스트 클래스 생성
1. 테스트들이 전부 성공했기 때문에 리팩토링을 위해서 나눠버린 코드들에 대해서 테스트 클래스를 생성했습니다.
2. 이미 익숙해진 기능들이기도 하고, 코드를 역할에 맞게 나눠서인지 각 테스트 클래스에서 많이 검증해야 하는 부분이 없었습니다.
3. 컨트롤러에서 DTO를 받아오지 않았던 문제들이 있었고, 그걸 집어넣기 위해 강제로 넣은 다음에 일일이 시그니처들을 변경하기 시작했습니다.

##### 6. DTO 검증
1. DTO 객체에서 데이터의 모양을 관리하기 때문에 DTO를 생성하는 시점에는 그 객체에 들어가는 데이터의 오류를 잡아내면 어떨까 생각이 들었습니다.
2. 그래서 DTO에서 기존에 서비스 단에서 수행하는 코드들 중에 타입에 관한 에러가 발생하는 부분을 같이 DTO에서 검증하기로 변경했습니다.
3. 테스트를 다시 진행해보니, 실패했습니다.
4. 실패한 이유를 찾아보니, 서비스 단에서 처리가 되기 전에 이미 데이터 생성에서 오류가 생기는 부분이 있었고 그에 대한 예외를 DTO에서 처리를 해주었습니다.
5. 테스트에서 발생하는 예외들에 대한 메시지를 변경하고, 테스트를 다시 진행해보니 성공했습니다.

##### 7. QueueManager 타임아웃 설정
1. QueueManager에서는 처리가 안 되어 있을 경우를 대비해서 타임아웃 설정이 되어있고, 타임아웃이 발생한 경우에서는 처리가 안 되었다고 결과를 보내줍니다.
2. 이에 대한 테스트는 실제로 각 테스트 별로 10초 이상 수행이 되기 때문에 생각보다 테스트를 통한 빠른 개발이 어렵지 않나 생각이 들었습니다.
3. 모킹을 한다면 어떨까? 라는 생각이 들었지만 정확하게 프로세스가 직접 대역이 되지 않는 이상 신뢰도가 떨어질 것 같다는 생각이 들었습니다.

##### 8. 서비스 레이어 리팩토링
1. 발제 내용 프레젠테이션을 유심히 보다 보니, 결국 레이어별 관심사는 요청에 대한 생성이지, 요청에 대한 수행이 아니지 않을까 라는 생각이 들었습니다.
2. 서비스 레이어에서는 서비스에 들어온 요청을 생성하고, 각 구현체들이 요청에 대한 처리를 수행하는 것에 중점을 두고, 다시 리팩토링을 진행했습니다.
3. 테스트를 다시 진행해보니 성공했습니다.

##### 9. 리포지터리 테스트
1. 리포지터리 영역에 대한 테스트입니다.
2. 서비스 구현체들이 리포지터리에 대한 의존도를 가지고 그 의존에 따라서 결과값을 받거나 못 받는데, 서비스에서 리포지터리에 대한 검증이 필요하다는 의미는 데이터를 중심으로 처리하는 것보다는, 기기 사양을 점검한다는 느낌이 강했습니다.
3. 그리하여 Mock으로 리포지터리에 대한 테스트를 진행했습니다.

